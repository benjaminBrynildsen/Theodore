import { useState } from 'react';
import { Download, BookOpen, Users, MapPin, Cog, Gem, Scale, Milestone, FileText, Loader2 } from 'lucide-react';
import { useStore } from '../../store';
import { useCanonStore } from '../../store/canon';
import { cn } from '../../lib/utils';
import type { CharacterEntry, LocationEntry } from '../../types/canon';

export function StoryBibleExport() {
  const { getActiveProject, getProjectChapters } = useStore();
  const { entries } = useCanonStore();
  const project = getActiveProject();
  const chapters = project ? getProjectChapters(project.id) : [];
  const canon = entries.filter(e => e.projectId === project?.id);

  const [format, setFormat] = useState<'markdown' | 'pdf' | 'docx'>('markdown');
  const [sections, setSections] = useState({
    overview: true,
    characters: true,
    locations: true,
    systems: true,
    artifacts: true,
    rules: true,
    events: true,
    timeline: true,
    chapterOutline: true,
  });
  const [exporting, setExporting] = useState(false);

  const toggleSection = (key: string) => {
    setSections(prev => ({ ...prev, [key]: !prev[key as keyof typeof prev] }));
  };

  const generateMarkdown = (): string => {
    if (!project) return '';
    const lines: string[] = [];

    lines.push(`# ${project.title} — Story Bible`);
    lines.push(`*Generated by Theodore · ${new Date().toLocaleDateString()}*\n`);

    if (sections.overview) {
      lines.push('## Project Overview');
      lines.push(`- **Type:** ${project.subtype || project.type}`);
      lines.push(`- **Length:** ${project.targetLength}`);
      lines.push(`- **Chapters:** ${chapters.length}`);
      lines.push(`- **Canon entries:** ${canon.length}\n`);
    }

    if (sections.characters) {
      const chars = canon.filter(e => e.type === 'character') as CharacterEntry[];
      if (chars.length > 0) {
        lines.push('## Characters\n');
        for (const c of chars) {
          const ch = c.character;
          lines.push(`### ${c.name}`);
          if (c.description) lines.push(c.description);
          lines.push(`- **Role:** ${ch.role}`);
          if (ch.age) lines.push(`- **Age:** ${ch.age}`);
          if (ch.occupation) lines.push(`- **Occupation:** ${ch.occupation}`);
          if (ch.personality.traits.length) lines.push(`- **Traits:** ${ch.personality.traits.join(', ')}`);
          if (ch.personality.speechPattern) lines.push(`- **Speech:** ${ch.personality.speechPattern}`);
          if (ch.arc.startingState) lines.push(`- **Arc start:** ${ch.arc.startingState}`);
          if (ch.arc.endingState) lines.push(`- **Arc end:** ${ch.arc.endingState}`);
          lines.push('');
        }
      }
    }

    if (sections.locations) {
      const locs = canon.filter(e => e.type === 'location') as LocationEntry[];
      if (locs.length > 0) {
        lines.push('## Locations\n');
        for (const l of locs) {
          lines.push(`### ${l.name}`);
          if (l.description) lines.push(l.description);
          if (l.location.locationType) lines.push(`- **Type:** ${l.location.locationType}`);
          if (l.location.currentState.atmosphere) lines.push(`- **Atmosphere:** ${l.location.currentState.atmosphere}`);
          lines.push('');
        }
      }
    }

    const otherTypes = [
      { key: 'systems', type: 'system', label: 'Systems' },
      { key: 'artifacts', type: 'artifact', label: 'Artifacts' },
      { key: 'rules', type: 'rule', label: 'Rules' },
      { key: 'events', type: 'event', label: 'Events' },
    ];
    for (const { key, type, label } of otherTypes) {
      if (sections[key as keyof typeof sections]) {
        const items = canon.filter(e => e.type === type);
        if (items.length > 0) {
          lines.push(`## ${label}\n`);
          for (const item of items) {
            lines.push(`### ${item.name}`);
            if (item.description) lines.push(item.description);
            lines.push('');
          }
        }
      }
    }

    if (sections.chapterOutline) {
      lines.push('## Chapter Outline\n');
      for (const ch of chapters) {
        lines.push(`### Chapter ${ch.number}: ${ch.title}`);
        if (ch.premise.purpose) lines.push(`**Purpose:** ${ch.premise.purpose}`);
        if (ch.premise.emotionalBeat) lines.push(`**Beat:** ${ch.premise.emotionalBeat}`);
        lines.push(`**Status:** ${ch.status} · ${ch.prose ? ch.prose.split(/\s+/).length + ' words' : 'unwritten'}`);
        lines.push('');
      }
    }

    return lines.join('\n');
  };

  const handleExport = async () => {
    setExporting(true);
    
    const md = generateMarkdown();
    
    if (format === 'markdown') {
      const blob = new Blob([md], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${project?.title || 'story'}-bible.md`;
      a.click();
      URL.revokeObjectURL(url);
    }
    // PDF and DOCX would need server-side conversion
    
    await new Promise(r => setTimeout(r, 500));
    setExporting(false);
  };

  if (!project) return null;

  const sectionItems = [
    { key: 'overview', label: 'Project Overview', icon: BookOpen },
    { key: 'characters', label: 'Characters', icon: Users, count: canon.filter(e => e.type === 'character').length },
    { key: 'locations', label: 'Locations', icon: MapPin, count: canon.filter(e => e.type === 'location').length },
    { key: 'systems', label: 'Systems', icon: Cog, count: canon.filter(e => e.type === 'system').length },
    { key: 'artifacts', label: 'Artifacts', icon: Gem, count: canon.filter(e => e.type === 'artifact').length },
    { key: 'rules', label: 'Rules', icon: Scale, count: canon.filter(e => e.type === 'rule').length },
    { key: 'events', label: 'Events', icon: Milestone, count: canon.filter(e => e.type === 'event').length },
    { key: 'chapterOutline', label: 'Chapter Outline', icon: FileText, count: chapters.length },
  ];

  return (
    <div className="p-5 space-y-4">
      <div>
        <h3 className="text-sm font-semibold mb-1">Story Bible Export</h3>
        <p className="text-xs text-text-tertiary">Export your complete canon as a formatted document for editors, co-authors, or adaptation teams.</p>
      </div>

      {/* Format */}
      <div>
        <label className="text-[10px] font-semibold text-text-tertiary uppercase tracking-wider mb-2 block">Format</label>
        <div className="flex gap-1">
          {(['markdown', 'pdf', 'docx'] as const).map(f => (
            <button key={f} onClick={() => setFormat(f)}
              className={cn('flex-1 py-2 rounded-xl text-xs font-medium uppercase transition-all',
                format === f ? 'bg-text-primary text-text-inverse' : 'glass-pill text-text-secondary'
              )}>{f}</button>
          ))}
        </div>
      </div>

      {/* Sections to include */}
      <div>
        <label className="text-[10px] font-semibold text-text-tertiary uppercase tracking-wider mb-2 block">Include</label>
        <div className="space-y-1">
          {sectionItems.map(({ key, label, icon: Icon, count }) => (
            <button
              key={key}
              onClick={() => toggleSection(key)}
              className="w-full flex items-center gap-2 px-3 py-2 rounded-lg hover:bg-black/3 transition-colors"
            >
              <div className={cn('w-4 h-4 rounded border flex items-center justify-center text-[10px] transition-all',
                sections[key as keyof typeof sections] ? 'bg-text-primary border-text-primary text-white' : 'border-black/15'
              )}>
                {sections[key as keyof typeof sections] && '✓'}
              </div>
              <Icon size={13} className="text-text-tertiary" />
              <span className="text-xs flex-1 text-left">{label}</span>
              {count !== undefined && <span className="text-[10px] text-text-tertiary">{count}</span>}
            </button>
          ))}
        </div>
      </div>

      <button
        onClick={handleExport}
        disabled={exporting}
        className="w-full py-3 rounded-xl bg-text-primary text-text-inverse text-sm font-medium flex items-center justify-center gap-2 hover:shadow-lg transition-all disabled:opacity-50"
      >
        {exporting ? <><Loader2 size={16} className="animate-spin" /> Exporting...</> : <><Download size={16} /> Export Story Bible</>}
      </button>
    </div>
  );
}
