import { useState, useRef, useEffect } from 'react';
import { Send, Sparkles, ChevronDown, Settings2, ArrowLeft } from 'lucide-react';
import { useStore } from '../../store';
import { useCanonStore } from '../../store/canon';
import { useSettingsStore } from '../../store/settings';
import { generateId, cn } from '../../lib/utils';
import { generateText } from '../../lib/generate';
import { api } from '../../lib/api';
import { Slider } from '../ui/Slider';
import { autoFillCharacter, autoFillLocation, extractCanonFromConversation } from '../../lib/ai-autofill';
import {
  getGenericRoleToken,
  getLeadingRoleToken,
  isAliasProneRoleToken,
  isGenericRoleCharacterName,
  isLikelyCharacterNoise,
  isLikelyEntityNoise,
  normalizeCharacterKey,
  normalizeEntityKey,
  normalizeEntityKeyForType,
  sanitizeEntityName,
} from '../../lib/entity-normalization';
import type { AutoGeneratedCanon } from '../../lib/ai-autofill';
import type { Project, NarrativeControls, BookSubtype } from '../../types';
import { CREDIT_COSTS } from '../../types/credits';
import { useAuthStore } from '../../store/auth';

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

interface ProposedSettings {
  title: string;
  subtype: BookSubtype;
  targetLength: Project['targetLength'];
  assistanceLevel: number;
  narrativeControls: NarrativeControls;
  chapterCount: number;
  chapters: { number: number; title: string; premise: string }[];
}

const SETTINGS_MARKER = 'THEODORE_SETTINGS_JSON:';
const CANON_MARKER = 'THEODORE_CANON_JSON:';
const CHAT_DRAFT_STORAGE_KEY = 'theodore-chat-creation-draft-v1';
const EMPTY_CANON_DRAFT: AutoGeneratedCanon = {
  characters: [],
  locations: [],
  systems: [],
  artifacts: [],
};

interface PersistedChatCreationDraft {
  version: 1;
  savedAt: string;
  messages: Array<{ id: string; role: 'user' | 'assistant'; content: string; timestamp: string }>;
  input: string;
  proposedSettings: ProposedSettings | null;
  editedSettings: ProposedSettings | null;
  hasManualSettingsEdits: boolean;
  aiCanonDraft: AutoGeneratedCanon;
}

function resolveModel(model: string): string {
  const map: Record<string, string> = {
    auto: 'gpt-4.1',
    'claude-opus': 'claude-opus-4-6',
    'claude-sonnet': 'claude-sonnet-4-5',
    'gpt-4o': 'gpt-4.1',
  };
  return map[model] || model;
}

function extractMarkerLine(text: string, marker: string): string | null {
  const idx = text.indexOf(marker);
  if (idx === -1) return null;
  const after = text.slice(idx + marker.length);
  return after.split('\n')[0].trim();
}

function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null;
}

function normalizeCanonDraft(raw: unknown): AutoGeneratedCanon {
  if (!isObject(raw)) return EMPTY_CANON_DRAFT;

  const timeWords = new Set([
    'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',
    'September', 'October', 'November', 'December',
    'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday',
    'Spring', 'Summer', 'Autumn', 'Fall', 'Winter',
    'Today', 'Tomorrow', 'Yesterday',
  ]);
  const isTimeLike = (name: string) => {
    const first = name.split(/\s+/)[0];
    return timeWords.has(name) || timeWords.has(first);
  };

  const artifactSuffix = /\b(?:Codex|Amulet|Sword|Key|Crown|Orb|Tome|Artifact|Relic|Device|Book)\b$/;
  const systemSuffix = /\b(?:System|Protocol|Order|Law|Magic)\b$/;
  const roleSet = new Set(['protagonist', 'antagonist', 'supporting', 'minor']);

  const characterRolePriority: Record<'minor' | 'supporting' | 'antagonist' | 'protagonist', number> = {
    minor: 0,
    supporting: 1,
    antagonist: 2,
    protagonist: 3,
  };

  const characterNameScore = (name: string): number => {
    const tokenCount = sanitizeEntityName(name).split(/\s+/).filter(Boolean).length;
    const genericRolePenalty = isGenericRoleCharacterName(name) ? -1 : 0;
    return tokenCount + genericRolePenalty + Math.min(name.length / 100, 0.5);
  };

  const toName = (value: unknown): string | null => {
    if (typeof value === 'string') {
      const name = sanitizeEntityName(value);
      return name && !isTimeLike(name) && !isLikelyEntityNoise(name) ? name : null;
    }
    if (isObject(value) && typeof value.name === 'string') {
      const name = sanitizeEntityName(value.name);
      return name && !isTimeLike(name) && !isLikelyEntityNoise(name) ? name : null;
    }
    return null;
  };

  const toDescription = (value: unknown, fallback: string): string => {
    if (isObject(value) && typeof value.description === 'string' && value.description.trim()) {
      return value.description.trim();
    }
    return fallback;
  };

  const charRaw = Array.isArray(raw.characters) ? raw.characters : [];
  const locRaw = Array.isArray(raw.locations) ? raw.locations : [];
  const sysRaw = Array.isArray(raw.systems) ? raw.systems : [];
  const artRaw = Array.isArray(raw.artifacts) ? raw.artifacts : [];

  const characters = charRaw.flatMap((item) => {
    const name = toName(item);
    if (!name || isLikelyCharacterNoise(name)) return [];
    const role =
      isObject(item) && typeof item.role === 'string' && roleSet.has(item.role)
        ? (item.role as 'protagonist' | 'antagonist' | 'supporting' | 'minor')
        : 'supporting';
    return [{
      name,
      role,
      description: toDescription(item, 'Character identified from planning chat.'),
    }];
  });

  const locations = locRaw.flatMap((item) => {
    const name = toName(item);
    if (!name) return [];
    return [{ name, description: toDescription(item, 'Location identified from planning chat.') }];
  });

  const systems = sysRaw.flatMap((item) => {
    const name = toName(item);
    if (!name) return [];
    return [{ name, description: toDescription(item, 'World/system concept identified from planning chat.') }];
  });

  const artifacts = artRaw.flatMap((item) => {
    const name = toName(item);
    if (!name) return [];
    return [{ name, description: toDescription(item, 'Artifact/object identified from planning chat.') }];
  });

  // Repair obvious mis-categorizations by suffix.
  for (let i = systems.length - 1; i >= 0; i -= 1) {
    if (artifactSuffix.test(systems[i].name)) {
      artifacts.push({ ...systems[i], description: 'Artifact/object identified from planning chat.' });
      systems.splice(i, 1);
    }
  }
  for (let i = artifacts.length - 1; i >= 0; i -= 1) {
    if (systemSuffix.test(artifacts[i].name)) {
      systems.push({ ...artifacts[i], description: 'World/system concept identified from planning chat.' });
      artifacts.splice(i, 1);
    }
  }

  const dedupeByName = <T extends { name: string }>(arr: T[]): T[] => {
    const seen = new Set<string>();
    return arr.filter((entry) => {
      const key = normalizeEntityKey(entry.name);
      if (!key || seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  };

  const dedupeCharacters = (
    arr: Array<{ name: string; role: 'protagonist' | 'antagonist' | 'supporting' | 'minor'; description: string }>,
  ) => {
    const byKey = new Map<string, { name: string; role: 'protagonist' | 'antagonist' | 'supporting' | 'minor'; description: string }>();
    for (const entry of arr) {
      if (isLikelyCharacterNoise(entry.name)) continue;
      const key = normalizeCharacterKey(entry.name) || normalizeEntityKey(entry.name);
      if (!key) continue;

      const existing = byKey.get(key);
      if (!existing) {
        byKey.set(key, entry);
        continue;
      }

      const preferredName = characterNameScore(entry.name) > characterNameScore(existing.name) ? entry.name : existing.name;
      const preferredRole =
        characterRolePriority[entry.role] > characterRolePriority[existing.role]
          ? entry.role
          : existing.role;
      const preferredDescription =
        entry.description.length > existing.description.length ? entry.description : existing.description;

      byKey.set(key, {
        name: preferredName,
        role: preferredRole,
        description: preferredDescription,
      });
    }

    const deduped = Array.from(byKey.values());
    const roleSpecifics = new Set(
      deduped
        .map((entry) => getLeadingRoleToken(entry.name))
        .filter((role): role is string => !!role),
    );
    const hasNamedCharacter = deduped.some(
      (entry) => !isGenericRoleCharacterName(entry.name) && entry.name.includes(' '),
    );

    return deduped.filter((entry) => {
      if (!isGenericRoleCharacterName(entry.name)) return true;
      const role = getGenericRoleToken(entry.name);
      if (!role) return true;
      if (roleSpecifics.has(role)) return false;
      if (hasNamedCharacter && isAliasProneRoleToken(role)) return false;
      return true;
    });
  };

  let canon: AutoGeneratedCanon = {
    characters: dedupeCharacters(characters),
    locations: dedupeByName(locations),
    systems: dedupeByName(systems),
    artifacts: dedupeByName(artifacts),
  };

  // Keep categories mutually exclusive; favor specific world objects over characters.
  const sysSet = new Set(canon.systems.map((s) => normalizeEntityKey(s.name)));
  const artSet = new Set(canon.artifacts.map((a) => normalizeEntityKey(a.name)));
  canon.locations = canon.locations.filter((l) => {
    const key = normalizeEntityKey(l.name);
    return key && !sysSet.has(key) && !artSet.has(key);
  });
  const locSet = new Set(canon.locations.map((l) => normalizeEntityKey(l.name)));
  canon.characters = canon.characters.filter((c) => {
    const charKey = normalizeCharacterKey(c.name) || normalizeEntityKey(c.name);
    return charKey && !locSet.has(charKey) && !sysSet.has(charKey) && !artSet.has(charKey);
  });

  return canon;
}

function mergeCanonDrafts(primary: AutoGeneratedCanon, fallback: AutoGeneratedCanon): AutoGeneratedCanon {
  return normalizeCanonDraft({
    characters: [...primary.characters, ...fallback.characters],
    locations: [...primary.locations, ...fallback.locations],
    systems: [...primary.systems, ...fallback.systems],
    artifacts: [...primary.artifacts, ...fallback.artifacts],
  });
}

function parseAssistantOutput(text: string): { message: string; settings?: ProposedSettings; canon?: AutoGeneratedCanon } {
  const settingsIdx = text.indexOf(SETTINGS_MARKER);
  const canonIdx = text.indexOf(CANON_MARKER);
  const markerIdxs = [settingsIdx, canonIdx].filter((i) => i >= 0);
  const firstIdx = markerIdxs.length ? Math.min(...markerIdxs) : -1;
  const message = (firstIdx === -1 ? text : text.slice(0, firstIdx)).trim();

  let settings: ProposedSettings | undefined;
  const settingsLine = extractMarkerLine(text, SETTINGS_MARKER);
  if (settingsLine) {
    try {
      const parsed = JSON.parse(settingsLine) as ProposedSettings;
      if (parsed.title && Array.isArray(parsed.chapters) && parsed.chapters.length > 0) {
        settings = parsed;
      }
    } catch {
      // ignore parse failure
    }
  }

  let canon: AutoGeneratedCanon | undefined;
  const canonLine = extractMarkerLine(text, CANON_MARKER);
  if (canonLine) {
    try {
      canon = normalizeCanonDraft(JSON.parse(canonLine));
    } catch {
      // ignore parse failure
    }
  }

  return { message, settings, canon };
}

function normalizeProposedSettings(raw: ProposedSettings): ProposedSettings {
  const fallbackTone = { lightDark: 50, hopefulGrim: 50, whimsicalSerious: 50 };
  const fallbackFocus = { character: 40, plot: 40, world: 20 };

  const normalizedChapters = (raw.chapters || [])
    .filter((ch) => ch && typeof ch.number === 'number')
    .map((ch, i) => ({
      number: i + 1,
      title: ch.title?.trim() || `Chapter ${i + 1}`,
      premise: ch.premise?.trim() || 'Advance character, conflict, and stakes.',
    }));

  const targetCount = Math.max(
    3,
    raw.chapterCount || 0,
    normalizedChapters.length,
  );

  while (normalizedChapters.length < targetCount) {
    const n = normalizedChapters.length + 1;
    normalizedChapters.push({
      number: n,
      title: `Chapter ${n}`,
      premise: 'Advance character, conflict, and stakes.',
    });
  }

  return {
    title: raw.title?.trim() || 'Untitled Novel',
    subtype: raw.subtype || 'novel',
    targetLength: raw.targetLength || 'medium',
    assistanceLevel: Number.isFinite(raw.assistanceLevel) ? raw.assistanceLevel : 3,
    narrativeControls: {
      toneMood: {
        lightDark: raw.narrativeControls?.toneMood?.lightDark ?? fallbackTone.lightDark,
        hopefulGrim: raw.narrativeControls?.toneMood?.hopefulGrim ?? fallbackTone.hopefulGrim,
        whimsicalSerious: raw.narrativeControls?.toneMood?.whimsicalSerious ?? fallbackTone.whimsicalSerious,
      },
      pacing: raw.narrativeControls?.pacing || 'balanced',
      dialogueWeight: raw.narrativeControls?.dialogueWeight || 'balanced',
      focusMix: {
        character: raw.narrativeControls?.focusMix?.character ?? fallbackFocus.character,
        plot: raw.narrativeControls?.focusMix?.plot ?? fallbackFocus.plot,
        world: raw.narrativeControls?.focusMix?.world ?? fallbackFocus.world,
      },
      genreEmphasis: raw.narrativeControls?.genreEmphasis || [],
    },
    chapterCount: targetCount,
    chapters: normalizedChapters,
  };
}

interface Props {
  onClose: () => void;
}

function createInitialAssistantMessage(): Message {
  return {
    id: generateId(),
    role: 'assistant',
    content: "You can call me Theo, let's work together.\n\nTell me about the story you want to write. What's the idea, the feeling, the world? Don't worry about structure yet.",
    timestamp: new Date(),
  };
}

export function ChatCreation({ onClose }: Props) {
  const [messages, setMessages] = useState<Message[]>(() => [createInitialAssistantMessage()]);
  const [input, setInput] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const [proposedSettings, setProposedSettings] = useState<ProposedSettings | null>(null);
  const [showSettings, setShowSettings] = useState(false);
  const [editedSettings, setEditedSettings] = useState<ProposedSettings | null>(null);
  const [creatingProject, setCreatingProject] = useState(false);
  const [quickStructuring, setQuickStructuring] = useState(false);
  const [creationMessage, setCreationMessage] = useState<string | null>(null);
  const [hasManualSettingsEdits, setHasManualSettingsEdits] = useState(false);
  const [aiCanonDraft, setAiCanonDraft] = useState<AutoGeneratedCanon>(EMPTY_CANON_DRAFT);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);
  const planHydrationSeqRef = useRef(0);

  const { addProject, setActiveProject, setCurrentView, addChapter } = useStore();
  const { createCharacter, createLocation, createSystem, createArtifact, createRule, createEvent, addEntry } = useCanonStore();
  const { settings } = useSettingsStore();
  const user = useAuthStore((s) => s.user);
  const userId = user?.id;

  useEffect(() => {
    try {
      const raw = localStorage.getItem(CHAT_DRAFT_STORAGE_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw) as Partial<PersistedChatCreationDraft>;
      if (parsed.version !== 1 || !Array.isArray(parsed.messages)) return;

      const hydratedMessages: Message[] = parsed.messages
        .filter((m): m is { id: string; role: 'user' | 'assistant'; content: string; timestamp: string } => (
          !!m && typeof m.id === 'string' && (m.role === 'user' || m.role === 'assistant') && typeof m.content === 'string' && typeof m.timestamp === 'string'
        ))
        .map((m) => ({
          id: m.id,
          role: m.role,
          content: m.content,
          timestamp: new Date(m.timestamp),
        }));

      if (!hydratedMessages.some((m) => m.role === 'user')) return;

      setMessages(hydratedMessages);
      if (typeof parsed.input === 'string') setInput(parsed.input);
      if (parsed.proposedSettings) setProposedSettings(normalizeProposedSettings(parsed.proposedSettings));
      if (parsed.editedSettings) setEditedSettings(normalizeProposedSettings(parsed.editedSettings));
      setHasManualSettingsEdits(!!parsed.hasManualSettingsEdits);
      if (parsed.aiCanonDraft) setAiCanonDraft(normalizeCanonDraft(parsed.aiCanonDraft));
    } catch {
      // Ignore malformed draft payloads.
    }
  }, []);

  useEffect(() => {
    const hasUserMessage = messages.some((m) => m.role === 'user');
    if (!hasUserMessage) return;

    const payload: PersistedChatCreationDraft = {
      version: 1,
      savedAt: new Date().toISOString(),
      messages: messages.map((m) => ({
        id: m.id,
        role: m.role,
        content: m.content,
        timestamp: m.timestamp.toISOString(),
      })),
      input,
      proposedSettings,
      editedSettings,
      hasManualSettingsEdits,
      aiCanonDraft,
    };

    try {
      localStorage.setItem(CHAT_DRAFT_STORAGE_KEY, JSON.stringify(payload));
    } catch {
      // Ignore storage quota / browser storage failures.
    }
  }, [messages, input, proposedSettings, editedSettings, hasManualSettingsEdits, aiCanonDraft]);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages, proposedSettings]);

  const applyProposedSettings = (next: ProposedSettings, preserveManualEdits = true) => {
    const normalized = normalizeProposedSettings(next);
    setProposedSettings(normalized);
    setEditedSettings((prev) => {
      if (preserveManualEdits && hasManualSettingsEdits && prev) return prev;
      return normalized;
    });
  };

  const updateEditedSettings = (updater: (prev: ProposedSettings) => ProposedSettings) => {
    setHasManualSettingsEdits(true);
    setEditedSettings((prev) => (prev ? updater(prev) : prev));
  };

  const deriveSettingsFromConversation = async (
    liveMessages: Message[],
  ): Promise<{ settings?: ProposedSettings; canon?: AutoGeneratedCanon } | null> => {
    if (!liveMessages.some((m) => m.role === 'user')) return null;
    try {
      const conversation = liveMessages.map((m) => `${m.role.toUpperCase()}: ${m.content}`).join('\n\n');
      const result = await generateText({
        userId,
        action: 'plan-project',
        model: resolveModel(settings.ai.preferredModel),
        temperature: 0.55,
        maxTokens: 1600,
        systemPrompt: `You maintain Theodore's live planning card while a conversation is still in progress.
Return EXACTLY two lines:
THEODORE_SETTINGS_JSON:{"title":"...","subtype":"novel","targetLength":"medium","assistanceLevel":3,"narrativeControls":{"toneMood":{"lightDark":50,"hopefulGrim":50,"whimsicalSerious":50},"pacing":"balanced","dialogueWeight":"balanced","focusMix":{"character":40,"plot":40,"world":20},"genreEmphasis":[]},"chapterCount":3,"chapters":[{"number":1,"title":"...","premise":"..."},{"number":2,"title":"...","premise":"..."},{"number":3,"title":"...","premise":"..."}]}
THEODORE_CANON_JSON:{"characters":[{"name":"...","role":"protagonist","description":"..."}],"locations":[{"name":"...","description":"..."}],"systems":[{"name":"...","description":"..."}],"artifacts":[{"name":"...","description":"..."}]}
Rules:
- Output only those two marker lines. No extra text.
- Assume even the first user message is enough to draft concrete story seeds.
- Always return at least 3 chapters based on current context.
- Infer at least 1 named protagonist and 1 named place immediately; include those names in chapter titles/premises.
- Keep canon categories mutually exclusive: a name can appear in only one category.
- Characters must be people, locations must be places, systems are world rules/mechanics, artifacts are objects.
- Use best-guess defaults for missing fields.
- Keep chapter titles and premises concise.`,
        prompt: `Conversation so far:\n${conversation}\n\nUpdate the live project settings.`,
      });
      const parsed = parseAssistantOutput(result.text || '');
      if (!parsed.settings && !parsed.canon) return null;
      return {
        settings: parsed.settings ? normalizeProposedSettings(parsed.settings) : undefined,
        canon: parsed.canon ? normalizeCanonDraft(parsed.canon) : undefined,
      };
    } catch {
      return null;
    }
  };

  const sendMessage = async () => {
    if (!input.trim() || isTyping) return;

    const userMessage: Message = {
      id: generateId(),
      role: 'user',
      content: input.trim(),
      timestamp: new Date(),
    };

    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setInput('');
    setIsTyping(true);

    try {
      const conversation = newMessages.map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\n\n');
      const result = await generateText({
        userId,
        action: 'plan-project',
        model: resolveModel(settings.ai.preferredModel),
        temperature: settings.ai.temperature,
        maxTokens: 2200,
        systemPrompt: `You are Theodore, an expert story architect helping users shape new fiction projects.
Keep responses concise, specific, and useful.
Style requirements:
- Keep your reply to 2-4 short paragraphs.
- Default to under 120 words unless the user explicitly asks for detail.
- Ask at most one focused follow-up question.
- Avoid repeating what the user already said.
Always append exactly two one-line markers:
THEODORE_SETTINGS_JSON:{"title":"...","subtype":"novel","targetLength":"medium","assistanceLevel":3,"narrativeControls":{"toneMood":{"lightDark":50,"hopefulGrim":50,"whimsicalSerious":50},"pacing":"balanced","dialogueWeight":"balanced","focusMix":{"character":40,"plot":40,"world":20},"genreEmphasis":[]},"chapterCount":12,"chapters":[{"number":1,"title":"...","premise":"..."}]}
THEODORE_CANON_JSON:{"characters":[{"name":"...","role":"protagonist","description":"..."}],"locations":[{"name":"...","description":"..."}],"systems":[{"name":"...","description":"..."}],"artifacts":[{"name":"...","description":"..."}]}
Rules for JSON markers:
- Both lines must be valid JSON on a single line each.
- chapterCount must match chapters.length.
- chapters must have at least 3 items.
- Use the first user message to infer concrete seeds immediately.
- Include at least 1 named protagonist and 1 named place in chapter titles/premises.
- Canon categories must be mutually exclusive: no name in multiple categories.
- Do not classify months, weekdays, or seasons as entities.`,
        prompt: `Conversation so far:\n${conversation}\n\nRespond as Theodore to the latest user message.`,
      });

      const parsed = parseAssistantOutput(result.text || '');
      const assistantMessage: Message = {
        id: generateId(),
        role: 'assistant',
        content: parsed.message || "Let's keep building your story idea.",
        timestamp: new Date(),
      };
      const updatedMessages = [...newMessages, assistantMessage];
      setMessages(updatedMessages);

      if (parsed.settings) {
        applyProposedSettings(parsed.settings, true);
      }
      if (parsed.canon) {
        setAiCanonDraft((prev) => mergeCanonDrafts(parsed.canon, prev));
      }

      const hydrationSeq = ++planHydrationSeqRef.current;
      void deriveSettingsFromConversation(updatedMessages).then((derived) => {
        if (!derived) return;
        if (hydrationSeq !== planHydrationSeqRef.current) return;
        if (derived.settings) applyProposedSettings(derived.settings, true);
        if (derived.canon) {
          setAiCanonDraft((prev) => mergeCanonDrafts(derived.canon, prev));
        }
      });
    } catch (error) {
      const msg = error instanceof Error ? error.message : 'Unknown error';
      setMessages(prev => [...prev, {
        id: generateId(),
        role: 'assistant',
        content: `I couldn't reach the model right now.\n\nError: ${msg}\n\nCheck Settings > Usage & Credits and try again.`,
        timestamp: new Date(),
      }]);
    } finally {
      setIsTyping(false);
    }
  };

  const createProjectFromSettings = async (settings: ProposedSettings) => {
    if (creatingProject) return;
    setCreationMessage(null);
    setCreatingProject(true);
    try {
      const finalSettings = normalizeProposedSettings(settings);
      const projectId = generateId();
      const now = new Date().toISOString();

      const project: Project = {
        id: projectId,
        title: finalSettings.title,
        type: 'book',
        subtype: finalSettings.subtype,
        targetLength: finalSettings.targetLength,
        toneBaseline: '',
        assistanceLevel: finalSettings.assistanceLevel,
        narrativeControls: finalSettings.narrativeControls,
        status: 'active',
        createdAt: now,
        updatedAt: now,
      };

      await addProject(project);

      for (const ch of finalSettings.chapters) {
        await addChapter({
          id: generateId(),
          projectId,
          number: ch.number,
          title: ch.title,
          timelinePosition: ch.number,
          status: 'premise-only',
          premise: {
            purpose: ch.premise,
            changes: '',
            characters: [],
            emotionalBeat: '',
            setupPayoff: [],
            constraints: [],
          },
          prose: '',
          referencedCanonIds: [],
          validationStatus: { isValid: true, checks: [] },
          createdAt: now,
          updatedAt: now,
        });
      }

      // Verify persistence; retry direct API writes if chapter rows were not saved.
      let persistedChapters = await api.listChapters(projectId).catch(() => []);
      if (!persistedChapters.length) {
        for (const ch of finalSettings.chapters) {
          await api.createChapter({
            id: generateId(),
            projectId,
            number: ch.number,
            title: ch.title,
            timelinePosition: ch.number,
            status: 'premise-only',
            premise: {
              purpose: ch.premise,
              changes: '',
              characters: [],
              emotionalBeat: '',
              setupPayoff: [],
              constraints: [],
            },
            prose: '',
            referencedCanonIds: [],
            validationStatus: { isValid: true, checks: [] },
            createdAt: now,
            updatedAt: now,
          }).catch(() => {});
        }
        persistedChapters = await api.listChapters(projectId).catch(() => []);
      }

      const localChapters = useStore.getState().getProjectChapters(projectId);
      if (!persistedChapters.length && !localChapters.length) {
        setMessages(prev => [...prev, {
          id: generateId(),
          role: 'assistant',
          content: 'Novel creation failed: chapter structure was not saved. Please try Create Novel again.',
          timestamp: new Date(),
        }]);
        setCreationMessage('Create failed: could not save chapter structure.');
        return;
      }

      if (!persistedChapters.length && localChapters.length) {
        setCreationMessage('Created locally. Sync to database is delayed, but your chapters are ready.');
      }

      // Auto-generate canon entries from full planning context, including generated settings.
      const planningCorpus = [
        ...messages.map((m) => m.content),
        finalSettings.title,
        ...finalSettings.chapters.map((ch) => `${ch.title}. ${ch.premise}`),
      ];
      const heuristicCanon = extractCanonFromConversation(planningCorpus);
      const canon = mergeCanonDrafts(aiCanonDraft, heuristicCanon);

      const existingNames = new Set<string>();
      const seenKey = (type: 'character' | 'location' | 'system' | 'artifact', name: string) => {
        const key = normalizeEntityKeyForType(type, name);
        return key ? `${type}:${key}` : '';
      };
      const markSeen = (type: 'character' | 'location' | 'system' | 'artifact', name: string) => {
        const key = seenKey(type, name);
        if (!key || existingNames.has(key)) return true;
        existingNames.add(key);
        return false;
      };

      canon.characters.forEach((c) => {
        if (isLikelyCharacterNoise(c.name)) return;
        if (markSeen('character', c.name)) return;
        const entry = createCharacter(projectId, c.name);
        entry.description = c.description;
        entry.character.role = c.role;
        entry.character = autoFillCharacter(entry);
        addEntry(entry);
      });

      canon.locations.forEach((l) => {
        if (isLikelyEntityNoise(l.name)) return;
        if (markSeen('location', l.name)) return;
        const entry = createLocation(projectId, l.name);
        entry.description = l.description;
        entry.location = autoFillLocation(entry);
        addEntry(entry);
      });

      canon.systems.forEach((s) => {
        if (isLikelyEntityNoise(s.name)) return;
        if (markSeen('system', s.name)) return;
        const entry = createSystem(projectId, s.name);
        entry.description = s.description;
        addEntry(entry);
      });

      canon.artifacts.forEach((a) => {
        if (isLikelyEntityNoise(a.name)) return;
        if (markSeen('artifact', a.name)) return;
        const entry = createArtifact(projectId, a.name);
        entry.description = a.description;
        addEntry(entry);
      });

      // Create one rule and one event scaffold so the canon has full coverage from the start.
      const baseRule = createRule(projectId, 'Core Story Rule');
      baseRule.description = 'Foundational rule inferred from planning context.';
      addEntry(baseRule);

      const baseEvent = createEvent(projectId, 'Inciting Event');
      baseEvent.description = 'Initial event that launches the story arc.';
      addEntry(baseEvent);

      setActiveProject(projectId);
      setCurrentView('project');
      localStorage.removeItem(CHAT_DRAFT_STORAGE_KEY);
      onClose();
    } finally {
      setCreatingProject(false);
    }
  };

  const createProject = async () => {
    const settings = editedSettings || proposedSettings;
    if (!settings) return;
    await createProjectFromSettings(settings);
  };

  const forceBuildStarterPlan = async (): Promise<ProposedSettings | null> => {
    if (quickStructuring) return null;
    setQuickStructuring(true);
    try {
      const conversation = messages.map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\n\n');
      const result = await generateText({
        userId,
        action: 'plan-project',
        model: resolveModel(settings.ai.preferredModel),
        temperature: 0.7,
        maxTokens: 2200,
        systemPrompt: `You are Theodore, an expert story architect.
Generate a complete starter plan from the available conversation context, even if incomplete.
Return three parts:
1) A short assistant message explaining assumptions made.
2) One line with:
THEODORE_SETTINGS_JSON:{"title":"...","subtype":"novel","targetLength":"medium","assistanceLevel":3,"narrativeControls":{"toneMood":{"lightDark":50,"hopefulGrim":50,"whimsicalSerious":50},"pacing":"balanced","dialogueWeight":"balanced","focusMix":{"character":40,"plot":40,"world":20},"genreEmphasis":[]},"chapterCount":3,"chapters":[{"number":1,"title":"...","premise":"..."},{"number":2,"title":"...","premise":"..."},{"number":3,"title":"...","premise":"..."}]}
3) One line with:
THEODORE_CANON_JSON:{"characters":[{"name":"...","role":"protagonist","description":"..."}],"locations":[{"name":"...","description":"..."}],"systems":[{"name":"...","description":"..."}],"artifacts":[{"name":"...","description":"..."}]}
Rules:
- Both marker lines must be valid JSON on a single line.
- Must include exactly 3 chapters.
- Infer concrete names/places from even a single user message.
- Include at least 1 named protagonist and 1 named place in chapter premises.
- Keep canon categories mutually exclusive and specific.
- Fill missing details with plausible defaults and state assumptions in the assistant message.`,
        prompt: `Build a ready-to-create starter plan using only what we already know.\n\nConversation:\n${conversation}`,
      });
      const parsed = parseAssistantOutput(result.text || '');
      if (!parsed.settings) {
        setMessages(prev => [...prev, {
          id: generateId(),
          role: 'assistant',
          content: 'I could not produce a valid 3-chapter starter yet. Try one more detail, then tap the button again.',
          timestamp: new Date(),
        }]);
        return null;
      }
      setMessages(prev => [...prev, {
        id: generateId(),
        role: 'assistant',
        content: parsed.message || 'Starter structure prepared from current context.',
        timestamp: new Date(),
      }]);
      setHasManualSettingsEdits(false);
      applyProposedSettings(parsed.settings, false);
      if (parsed.canon) {
        setAiCanonDraft((prev) => mergeCanonDrafts(parsed.canon, prev));
      }
      return parsed.settings;
    } catch (error) {
      const msg = error instanceof Error ? error.message : 'Unknown error';
      setMessages(prev => [...prev, {
        id: generateId(),
        role: 'assistant',
        content: `Could not build a starter structure yet.\n\nError: ${msg}`,
        timestamp: new Date(),
      }]);
      return null;
    } finally {
      setQuickStructuring(false);
    }
  };

  const selectedSettings = editedSettings || proposedSettings;
  const conversationInputs = messages.map((m) => m.content);
  const settingsInputs = selectedSettings
    ? [selectedSettings.title, ...selectedSettings.chapters.map((ch) => `${ch.title}. ${ch.premise}`)]
    : [];
  const heuristicSeedPreview = extractCanonFromConversation([...conversationInputs, ...settingsInputs]);
  const seedPreview = mergeCanonDrafts(aiCanonDraft, heuristicSeedPreview);
  const canonSeedCount =
    seedPreview.characters.length +
    seedPreview.locations.length +
    seedPreview.systems.length +
    seedPreview.artifacts.length +
    2; // base rule + base event
  const starterPlanCredits = selectedSettings ? 0 : CREDIT_COSTS['plan-project'].typical;
  const createCostRows = [
    {
      label: selectedSettings ? 'Starter structure' : 'Generate starter structure',
      credits: starterPlanCredits,
      detail: selectedSettings ? 'Already prepared from chat context.' : 'One planning pass to draft title + first 3 chapters.',
    },
    {
      label: 'Create project + chapters',
      credits: 0,
      detail: 'Writes project/chapter records to your local database.',
    },
    {
      label: 'Seed canon metadata',
      credits: 0,
      detail: 'Auto-fills characters, places, systems, and artifacts from chat.',
    },
    {
      label: 'First full chapter (optional)',
      credits: CREDIT_COSTS['generate-chapter-full'].typical,
      detail: 'Run in chapter view when you are ready to draft.',
    },
  ];
  const createNowCredits = createCostRows.slice(0, 3).reduce((sum, row) => sum + row.credits, 0);

  return (
    <div className="flex-1 flex flex-col bg-bg animate-fade-in overflow-hidden">
        {/* Header */}
        <div className="flex items-center justify-between px-4 sm:px-6 py-3 sm:py-4 border-b border-black/5">
          <button onClick={onClose} className="flex items-center gap-1 text-text-tertiary hover:text-text-primary text-sm transition-colors">
            <ArrowLeft size={16} />
            <span>Back</span>
          </button>
          <div className="flex items-center gap-2">
            <Sparkles size={16} className="text-text-primary" />
            <span className="text-sm font-medium">Plan Your Story</span>
          </div>
          <div className="w-12" /> {/* Spacer for centering */}
        </div>

        {/* Messages */}
        <div className="flex-1 overflow-hidden px-4 sm:px-6 py-4">
          <div className="max-w-7xl mx-auto w-full h-full grid grid-cols-1 lg:grid-cols-[minmax(0,60%)_minmax(0,30%)] gap-6 lg:gap-8 items-stretch">
          <div className="w-full">
          <div className="rounded-[28px] border border-black/10 bg-white/75 shadow-2xl backdrop-blur-md overflow-hidden mx-auto flex flex-col h-full min-h-0">
            <div className="flex items-center justify-between px-5 sm:px-6 py-4 border-b border-black/10">
              <div className="text-[11px] font-semibold uppercase tracking-wider text-text-tertiary">Conversation</div>
              <div className="text-[11px] text-text-tertiary">{messages.length} messages</div>
            </div>

            <div className="flex-1 overflow-y-auto p-4 sm:p-5">
              <div className="rounded-2xl border border-black/8 bg-white/55 p-3 sm:p-4 space-y-4 min-h-full">
              {messages.map((msg) => (
                <div
                  key={msg.id}
                  className={cn(
                    'animate-fade-in max-w-[90%]',
                    msg.role === 'user' ? 'ml-auto' : ''
                  )}
                >
                  <div
                    className={cn(
                      'px-4 py-3 rounded-2xl text-sm leading-relaxed whitespace-pre-line',
                      msg.role === 'user'
                        ? 'bg-text-primary text-text-inverse rounded-br-md border border-black/15 shadow-md'
                        : 'bg-white/70 border border-black/10 rounded-bl-md shadow-sm'
                    )}
                  >
                    {msg.content.split(/(\*\*.*?\*\*)/).map((part, i) => {
                      if (part.startsWith('**') && part.endsWith('**')) {
                        return <strong key={i}>{part.slice(2, -2)}</strong>;
                      }
                      return part;
                    })}
                  </div>
                </div>
              ))}

              {/* Typing indicator */}
              {isTyping && (
                <div className="animate-fade-in">
                  <div className="bg-white/70 border border-black/10 px-4 py-3 rounded-2xl rounded-bl-md w-fit shadow-sm">
                    <div className="flex gap-1.5">
                      <span className="w-2 h-2 bg-text-tertiary rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                      <span className="w-2 h-2 bg-text-tertiary rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                      <span className="w-2 h-2 bg-text-tertiary rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                    </div>
                  </div>
                </div>
              )}

              <div ref={messagesEndRef} />
              </div>
            </div>

            <div className="border-t border-black/10 p-3 sm:p-4 bg-white/60">
              <div className="flex items-center gap-3 rounded-2xl border border-black/10 bg-white/80 shadow-sm p-2.5">
                <textarea
                  ref={inputRef}
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                      e.preventDefault();
                      sendMessage();
                    }
                  }}
                  placeholder="Tell me about your story..."
                  rows={1}
                  className="flex-1 h-11 min-h-11 max-h-11 overflow-y-auto bg-transparent border-none outline-none resize-none text-sm px-3 py-2 leading-relaxed"
                />
                <button
                  onClick={sendMessage}
                  disabled={!input.trim() || isTyping}
                  className={cn(
                    'h-11 w-11 flex items-center justify-center rounded-2xl transition-all',
                    input.trim() && !isTyping
                      ? 'bg-text-primary text-text-inverse shadow-md hover:shadow-lg active:scale-95'
                      : 'glass-pill text-text-tertiary'
                  )}
                >
                  <Send size={16} />
                </button>
              </div>
              {selectedSettings && (
                <button
                  onClick={createProject}
                  disabled={creatingProject}
                  className="mt-3 w-full lg:hidden py-3 rounded-xl bg-text-primary text-text-inverse text-sm font-semibold shadow-md hover:shadow-lg active:scale-[0.98] transition-all disabled:opacity-60"
                >
                  {creatingProject ? 'Creating Novel...' : 'Create Novel'}
                </button>
              )}
            </div>
          </div>
          </div>

          <aside className="hidden lg:block w-full">
            <div className="sticky top-20 glass rounded-3xl p-6 border border-black/10 shadow-xl w-full max-h-[calc(100vh-6.5rem)] overflow-y-auto">
              <div className="text-[10px] font-semibold text-text-tertiary uppercase tracking-wider mb-2">Ready</div>
              <h3 className="font-serif text-2xl font-semibold mb-2">Create Novel</h3>
              <p className="text-xs text-text-tertiary mb-4">
                Create project, chapters, and canon metadata from your current planning context.
              </p>

              <button
                onClick={selectedSettings ? createProject : forceBuildStarterPlan}
                disabled={creatingProject || quickStructuring}
                className="w-full py-5 rounded-2xl bg-text-primary text-text-inverse text-lg font-semibold shadow-lg hover:shadow-2xl active:scale-[0.98] transition-all disabled:opacity-60"
              >
                {creatingProject
                  ? 'Creating Novel...'
                  : selectedSettings
                  ? 'Create Novel'
                  : quickStructuring
                  ? 'Building Starter...'
                  : 'Generate Starter + Create'}
              </button>

              <div className="mt-3 rounded-2xl border border-black/10 bg-white/55 px-4 py-3">
                <div className="flex items-center justify-between">
                  <span className="text-[10px] font-semibold uppercase tracking-wider text-text-tertiary">Cost Breakdown</span>
                  <span className="text-xs font-semibold">{createNowCredits} credits now</span>
                </div>
                <div className="mt-2 space-y-2">
                  {createCostRows.map((row) => (
                    <div key={row.label} className="rounded-xl bg-white/70 px-3 py-2 border border-black/5">
                      <div className="flex items-center justify-between gap-2">
                        <span className="text-xs font-medium text-text-primary">{row.label}</span>
                        <span className="text-xs font-semibold">{row.credits} cr</span>
                      </div>
                      <div className="text-[10px] text-text-tertiary mt-0.5">{row.detail}</div>
                    </div>
                  ))}
                </div>
              </div>

              <div className="grid grid-cols-2 gap-2 text-xs mb-4">
                <div className="glass-pill px-3 py-2 rounded-xl">
                  Chapters: {selectedSettings?.chapters.length || 0}
                </div>
                <div className="glass-pill px-3 py-2 rounded-xl">
                  Canon Seeds: {canonSeedCount}
                </div>
              </div>

              <div className="space-y-3 mb-5">
                <div className="text-[10px] font-semibold uppercase tracking-wider text-text-tertiary">Live Canon Draft</div>
                <div className="glass-pill px-3 py-2 rounded-xl text-xs">
                  Characters ({seedPreview.characters.length}): {seedPreview.characters.map((c) => c.name).slice(0, 5).join(', ')}
                </div>
                <div className="glass-pill px-3 py-2 rounded-xl text-xs">
                  Places ({seedPreview.locations.length}): {seedPreview.locations.map((l) => l.name).slice(0, 5).join(', ')}
                </div>
                {seedPreview.systems.length > 0 && (
                  <div className="glass-pill px-3 py-2 rounded-xl text-xs">
                    Systems ({seedPreview.systems.length}): {seedPreview.systems.map((s) => s.name).slice(0, 4).join(', ')}
                  </div>
                )}
                {seedPreview.artifacts.length > 0 && (
                  <div className="glass-pill px-3 py-2 rounded-xl text-xs">
                    Artifacts ({seedPreview.artifacts.length}): {seedPreview.artifacts.map((a) => a.name).slice(0, 4).join(', ')}
                  </div>
                )}
              </div>

              {creationMessage && (
                <div className="mt-2 text-xs text-text-tertiary">{creationMessage}</div>
              )}

              {selectedSettings && (
                <div className="mt-5 bg-white/60 rounded-2xl border border-black/10 overflow-hidden">
                  <button
                    onClick={() => setShowSettings(!showSettings)}
                    className="w-full flex items-center justify-between px-5 py-4 hover:bg-white/40 transition-colors"
                  >
                    <div className="flex items-center gap-2">
                      <Settings2 size={16} />
                      <span className="text-sm font-medium">Proposed Settings</span>
                    </div>
                    <ChevronDown size={16} className={cn('transition-transform', showSettings && 'rotate-180')} />
                  </button>

                  {showSettings && (
                    <div className="px-5 pb-5 space-y-4 border-t border-black/5 pt-4 animate-fade-in">
                      <div>
                        <label className="text-xs font-medium text-text-tertiary uppercase tracking-wider">Title</label>
                        <input
                          type="text"
                          value={selectedSettings.title}
                          onChange={(e) => updateEditedSettings((prev) => ({ ...prev, title: e.target.value }))}
                          className="w-full mt-1 px-3 py-2 rounded-xl glass-input text-sm"
                        />
                      </div>

                      <div>
                        <label className="text-xs font-medium text-text-tertiary uppercase tracking-wider">Length</label>
                        <div className="flex gap-2 mt-1">
                          {(['short', 'medium', 'long', 'epic'] as const).map((len) => (
                            <button
                              key={len}
                              onClick={() => updateEditedSettings((prev) => ({ ...prev, targetLength: len }))}
                              className={cn(
                                'flex-1 py-2 text-xs rounded-xl transition-all capitalize',
                                selectedSettings.targetLength === len
                                  ? 'bg-text-primary text-text-inverse shadow-md'
                                  : 'glass-pill text-text-secondary hover:bg-white/60'
                              )}
                            >
                              {len}
                            </button>
                          ))}
                        </div>
                      </div>

                      <div>
                        <label className="text-xs font-medium text-text-tertiary uppercase tracking-wider">Tone</label>
                        <div className="space-y-2 mt-2">
                          <Slider
                            value={selectedSettings.narrativeControls.toneMood.lightDark}
                            onChange={(v) => updateEditedSettings((prev) => ({
                              ...prev,
                              narrativeControls: { ...prev.narrativeControls, toneMood: { ...prev.narrativeControls.toneMood, lightDark: v } }
                            }))}
                            leftLabel="Light"
                            rightLabel="Dark"
                          />
                          <Slider
                            value={selectedSettings.narrativeControls.toneMood.hopefulGrim}
                            onChange={(v) => updateEditedSettings((prev) => ({
                              ...prev,
                              narrativeControls: { ...prev.narrativeControls, toneMood: { ...prev.narrativeControls.toneMood, hopefulGrim: v } }
                            }))}
                            leftLabel="Hopeful"
                            rightLabel="Grim"
                          />
                          <Slider
                            value={selectedSettings.narrativeControls.toneMood.whimsicalSerious}
                            onChange={(v) => updateEditedSettings((prev) => ({
                              ...prev,
                              narrativeControls: { ...prev.narrativeControls, toneMood: { ...prev.narrativeControls.toneMood, whimsicalSerious: v } }
                            }))}
                            leftLabel="Whimsical"
                            rightLabel="Serious"
                          />
                        </div>
                      </div>

                      <div>
                        <label className="text-xs font-medium text-text-tertiary uppercase tracking-wider">Pacing</label>
                        <div className="flex gap-1 mt-1 glass-pill p-1 rounded-xl">
                          {(['slow', 'balanced', 'fast'] as const).map((p) => (
                            <button
                              key={p}
                              onClick={() => updateEditedSettings((prev) => ({
                                ...prev,
                                narrativeControls: { ...prev.narrativeControls, pacing: p }
                              }))}
                              className={cn(
                                'flex-1 py-1.5 text-xs rounded-lg transition-all capitalize',
                                selectedSettings.narrativeControls.pacing === p
                                  ? 'bg-text-primary text-text-inverse shadow-sm'
                                  : 'text-text-secondary'
                              )}
                            >
                              {p}
                            </button>
                          ))}
                        </div>
                      </div>
                    </div>
                  )}

                  <div className="px-5 pb-4 border-t border-black/5 pt-4">
                    <h4 className="text-xs font-medium text-text-tertiary uppercase tracking-wider mb-3">
                      {selectedSettings.chapters.length} Chapters Planned
                    </h4>
                    <div className="space-y-2 max-h-52 overflow-y-auto">
                      {selectedSettings.chapters.map((ch) => (
                        <div key={ch.number} className="flex gap-3 text-sm">
                          <span className="text-text-tertiary font-mono text-xs mt-0.5 w-6 text-right flex-shrink-0">{ch.number}</span>
                          <div className="min-w-0">
                            <div className="font-medium text-sm">{ch.title}</div>
                            <div className="text-xs text-text-secondary line-clamp-2">{ch.premise}</div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              )}
            </div>
          </aside>
          </div>
        </div>

        
    </div>
  );
}
